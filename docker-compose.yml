# ============================================================================
# Docker Compose Configuration for DogMatch Backend
# ============================================================================
# Purpose: Define and run multi-container application for local development
# 
# Usage:
#   Start all services:     docker-compose up
#   Start in background:    docker-compose up -d
#   Stop all services:      docker-compose down
#   View logs:              docker-compose logs -f backend
#   Rebuild:                docker-compose up --build
# ============================================================================

version: '3.8'  # Docker Compose file format version

# ============================================================================
# SERVICES (Containers)
# ============================================================================
services:
  
  # --------------------------------------------------------------------------
  # MySQL Database
  # --------------------------------------------------------------------------
  mysql:
    # Use official MySQL 8.0 image
    image: mysql:8.0
    
    # Container name (easier to reference)
    container_name: dogmatch_mysql
    
    # Restart policy: always restart if container crashes
    restart: unless-stopped
    
    # Load environment variables from .env file
    env_file:
      - .env
    
    # Environment variables for MySQL
    # Using your .env credentials to avoid confusion!
    environment:
      # Root password (using your DB_PASSWORD from .env)
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      
      # Create a database on startup (using your DB_NAME from .env)
      MYSQL_DATABASE: ${DB_NAME}
      
      # Create a user with access to the database (using your DB_USER from .env)
      MYSQL_USER: ${DB_USER}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      
      # Character set (important for emoji support!)
      MYSQL_CHARACTER_SET_SERVER: utf8mb4
      MYSQL_COLLATION_SERVER: utf8mb4_unicode_ci
    
    # Persistent storage for database data
    # Without this, all data is lost when container stops!
    volumes:
      # Mount named volume 'mysql_data' to MySQL's data directory
      - mysql_data:/var/lib/mysql
      
      # Optional: Custom MySQL configuration
      # - ./docker/mysql/my.cnf:/etc/mysql/conf.d/my.cnf
    
    # Expose port 3306 (MySQL default) to host machine
    # Format: "host_port:container_port"
    ports:
      - "3306:3306"
    
    # Health check to know when MySQL is ready
    healthcheck:
      # Try to login and run a simple query
      # Using a shell command to properly handle password with special characters
      test: ["CMD-SHELL", "mysqladmin ping -h localhost -u root -p\"$$MYSQL_ROOT_PASSWORD\" || exit 1"]
      interval: 10s      # Check every 10 seconds
      timeout: 5s        # Fail if command takes > 5 seconds
      retries: 10        # Try 10 times before marking unhealthy (MySQL can take time to start)
      start_period: 60s  # Wait 60 seconds before first check (MySQL initialization can take time)
    
    # Connect to custom network
    networks:
      - dogmatch-network

  # --------------------------------------------------------------------------
  # Using SimpleCache (in-memory) for local caching
  # --------------------------------------------------------------------------

  # --------------------------------------------------------------------------
  # Backend (Flask Application)
  # --------------------------------------------------------------------------
  backend:
    # Build from Dockerfile in current directory
    build:
      context: .           # Build context (where Dockerfile is)
      dockerfile: Dockerfile
    
    container_name: dogmatch_backend
    restart: unless-stopped
    
    # Load environment variables from .env file
    env_file:
      - .env
    
    # Override specific vars for local Docker environment
    environment:
      # Flask configuration for local development
      FLASK_ENV: development  # Use DevelopmentConfig
      FLASK_DEBUG: "true"     # Enable debug mode for local dev
      
      # Database connection - OVERRIDE to use local MySQL container
      # Use individual components instead of DATABASE_URL to avoid URL parsing issues
      # The Config class will construct DATABASE_URL from these if DATABASE_URL is not set
      DB_HOST: mysql          # Container name (Docker DNS resolves this)
      DB_PORT: 3306
      DB_USER: ${DB_USER}
      DB_PASSWORD: ${DB_PASSWORD}
      DB_NAME: ${DB_NAME}
      # IMPORTANT: Override DATABASE_URL to use container name 'mysql' instead of 'localhost'
      # The entrypoint script uses DATABASE_URL, so we must override it here
      # Construct DATABASE_URL from .env variables, but use 'mysql' as host (container name)
      DATABASE_URL: mysql+pymysql://${DB_USER}:${DB_PASSWORD}@mysql:3306/${DB_NAME}
      
      # JWT secrets, AWS credentials, etc. all come from .env
      
      # Performance tuning for development
      GUNICORN_WORKERS: 2
      GUNICORN_THREADS: 2
      
      # Create admin on startup
      CREATE_ADMIN: "true"
    
    # Volumes for development (hot reload!)
    volumes:
      # Mount your local code into the container
      # Changes to code are immediately reflected without rebuild!
      - ./app:/app/app:ro         # :ro = read-only (container can't modify your code)
      - ./migrations:/app/migrations
      
      # Persistent storage for logs
      - logs:/app/logs
      
      # Note: No volume for dog_photos - all photos stored in S3!
    
    # Expose Flask port to host
    ports:
      - "5002:5002"
    
    # Wait for MySQL to be healthy before starting
    depends_on:
      mysql:
        condition: service_healthy  # Wait for MySQL healthcheck to pass
    
    # Add health check for backend service
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5002/api/health/live"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    
    networks:
      - dogmatch-network
    
    # For development with Flask dev server (hot reload):
    # command: ["python", "run.py"]
    
    # For production-like testing with Gunicorn:
    # Uses wsgi.py which handles gevent monkey patching
    # The CMD from Dockerfile will be used automatically

  # --------------------------------------------------------------------------
  # Adminer (Database Management UI) - Optional but useful!
  # --------------------------------------------------------------------------
  adminer:
    # Lightweight database management interface
    image: adminer:latest
    
    container_name: dogmatch_adminer
    restart: unless-stopped
    
    # Expose Adminer web interface
    ports:
      - "8080:8080"
    
    # Only start if you want to manage the database
    # Can be disabled by running: docker-compose up backend
    depends_on:
      - mysql
    
    networks:
      - dogmatch-network
    
    # Adminer design (optional - makes it look nicer)
    environment:
      ADMINER_DEFAULT_SERVER: mysql
      ADMINER_DESIGN: dracula

# ============================================================================
# NETWORKS
# ============================================================================
# Create a custom network so containers can communicate by name
networks:
  dogmatch-network:
    driver: bridge  # Standard Docker network driver

# ============================================================================
# VOLUMES (Persistent Storage)
# ============================================================================
# Named volumes for data that should survive container restarts
volumes:
  # MySQL database files - ESSENTIAL (contains all user/dog/match data)
  # Backup available in: dogmatch_backup_complete.sql
  mysql_data:
    driver: local
  
  # Application logs - debugging and monitoring
  logs:
    driver: local
  
  # Note: No volume for photos - all photos are stored in AWS S3!
  # Database only contains S3 URLs, not actual image files