name: Deploy Backend to Azure Container Apps

on:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read

env:
  AZURE_RESOURCE_GROUP: dogmatch-app
  AZURE_CONTAINERAPPS_ENVIRONMENT: dogmatch-env
  AZURE_CONTAINER_REGISTRY_LOGIN_SERVER: dogmtachcr.azurecr.io
  CONTAINER_APP_NAME: dogmatch-backend

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Login to Azure (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Azure CLI - Log in to ACR
      run: |
        az acr login --name dogmtachcr

    - name: Build Docker image
      run: |
        IMAGE_TAG=${{ env.AZURE_CONTAINER_REGISTRY_LOGIN_SERVER }}/dogmatch-backend:${{ github.sha }}
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
        docker build -t $IMAGE_TAG .

    - name: Push Docker image
      run: |
        docker push $IMAGE_TAG

    - name: Deploy to Azure Container Apps
      run: |
        # First, update the image and basic configuration
        # IMPORTANT: Update ingress configuration FIRST, then image
        az containerapp ingress enable \
          --name $CONTAINER_APP_NAME \
          --resource-group $AZURE_RESOURCE_GROUP \
          --type external \
          --target-port 5002 \
          --transport http \
          --allow-insecure
        
        # Then update the image and other settings
        az containerapp update \
          --name $CONTAINER_APP_NAME \
          --resource-group $AZURE_RESOURCE_GROUP \
          --image $IMAGE_TAG \
          --set properties.template.scale.minReplicas=1 \
          --set properties.template.scale.maxReplicas=1 \
          --set-env-vars \
            FLASK_ENV=production \
            DATABASE_URL=${{ secrets.DATABASE_URL }} \
            REDIS_URL=${{ secrets.REDIS_URL }} \
            SECRET_KEY="${{ secrets.SECRET_KEY }}" \
            JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}" \
            AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            AWS_DEFAULT_REGION="${{ secrets.AWS_DEFAULT_REGION }}" \
            S3_BUCKET_NAME="${{ secrets.S3_BUCKET_NAME }}" \
            GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY }}" \
            JWT_ACCESS_TOKEN_EXPIRES="${{ secrets.JWT_ACCESS_TOKEN_EXPIRES }}" \
            JWT_REFRESH_TOKEN_EXPIRES="${{ secrets.JWT_REFRESH_TOKEN_EXPIRES }}"
        
        # Wait for the update to complete and propagate
        echo "Waiting for environment variables to update..."
        sleep 10
        
        # Get current container app configuration and update probes using Python
        python3 << EOF
        import json
        import subprocess
        import sys
        import os
        import time
        
        container_app_name = os.environ['CONTAINER_APP_NAME']
        resource_group = os.environ['AZURE_RESOURCE_GROUP']
        
        # Retry getting the config to ensure we have the latest
        config = None
        for attempt in range(3):
            result = subprocess.run(
                ['az', 'containerapp', 'show', 
                 '--name', container_app_name,
                 '--resource-group', resource_group,
                 '--output', 'json'],
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                print(f"Error getting container app (attempt {attempt+1}/3): {result.stderr}", file=sys.stderr)
                if attempt < 2:
                    time.sleep(5)
                    continue
                sys.exit(1)
            
            config = json.loads(result.stdout)
            
            # Check if REDIS_URL was updated (verify the update propagated)
            env_vars = config.get('properties', {}).get('template', {}).get('containers', [{}])[0].get('env', [])
            redis_url_found = False
            for env_var in env_vars:
                if env_var.get('name') == 'REDIS_URL':
                    redis_url_found = True
                    redis_value = env_var.get('value', '')
                    # Check if it's the new Redis Labs URL
                    if 'redislabs.com' in redis_value or 'rediss://' in redis_value:
                        print(f"✅ REDIS_URL updated correctly")
                        break
                    else:
                        print(f"⚠️ REDIS_URL still has old value, waiting for update to propagate...")
                        if attempt < 2:
                            time.sleep(5)
                            continue
            
            if redis_url_found:
                break
        
        if config is None:
            print("Failed to get container app configuration", file=sys.stderr)
            sys.exit(1)
        
        # Define probes
        # Startup: Frequent during startup (only runs until success)
        # Liveness: Less frequent - just checks if app is alive
        # Readiness: Moderate frequency - checks if ready for traffic
        probes = [
            {
                "type": "Startup",
                "httpGet": {
                    "path": "/api/health/live",
                    "port": 5002,
                    "scheme": "HTTP"
                },
                "initialDelaySeconds": 10,
                "periodSeconds": 5,
                "timeoutSeconds": 3,
                "failureThreshold": 30,
                "successThreshold": 1
            },
            {
                "type": "Liveness",
                "httpGet": {
                    "path": "/api/health/live",
                    "port": 5002,
                    "scheme": "HTTP"
                },
                "initialDelaySeconds": 30,
                "periodSeconds": 30,
                "timeoutSeconds": 5,
                "failureThreshold": 3,
                "successThreshold": 1
            },
            {
                "type": "Readiness",
                "httpGet": {
                    "path": "/api/health/ready",
                    "port": 5002,
                    "scheme": "HTTP"
                },
                "initialDelaySeconds": 10,
                "periodSeconds": 15,
                "timeoutSeconds": 3,
                "failureThreshold": 3,
                "successThreshold": 1
            }
        ]
        
        # Update probes in the existing container config
        # Get the existing container to preserve all settings INCLUDING env vars
        existing_container = config['properties']['template']['containers'][0].copy()
        
        # Log current env vars for debugging
        print("Current environment variables:")
        for env_var in existing_container.get('env', []):
            name = env_var.get('name', 'unknown')
            # Don't print sensitive values
            if 'SECRET' in name or 'PASSWORD' in name or 'KEY' in name:
                print(f"  {name}: [REDACTED]")
            else:
                value = env_var.get('value', '')
                # Truncate long values
                display_value = value[:50] + '...' if len(value) > 50 else value
                print(f"  {name}: {display_value}")
        
        # Clean up any invalid environment variables (like ingress properties)
        # Filter out env vars that start with "properties."
        valid_env_vars = []
        invalid_count = 0
        for env_var in existing_container.get('env', []):
            env_name = env_var.get('name', '')
            if env_name.startswith('properties.'):
                invalid_count += 1
                print(f"  Removing invalid env var: {env_name}")
            else:
                valid_env_vars.append(env_var)
        
        if invalid_count > 0:
            print(f"Removed {invalid_count} invalid environment variables")
        
        # Update the container with cleaned env vars
        existing_container['env'] = valid_env_vars
        
        # Add probes to container
        existing_container['probes'] = probes
        
        # IMPORTANT: The env vars were set by az containerapp update above
        # The existing_container already has the updated env vars from the update command
        # We preserve them by copying the entire container config
        
        # For PATCH, send the template with updated probes
        # This preserves all other container settings (env vars, resources, etc.)
        update_payload = {
            'properties': {
                'template': {
                    'containers': [existing_container]
                }
            }
        }
        
        # Save update payload as JSON
        with open('/tmp/containerapp-updated.json', 'w') as f:
            json.dump(update_payload, f)
        
        print("Configuration updated successfully")
        EOF
        
        # Apply the updated configuration using az rest (PATCH operation)
        # Get the subscription ID
        SUBSCRIPTION_ID=$(az account show --query id -o tsv)
        
        # Use az rest to update the container app with the PATCH payload
        az rest --method PATCH \
          --uri "https://management.azure.com/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${AZURE_RESOURCE_GROUP}/providers/Microsoft.App/containerApps/${CONTAINER_APP_NAME}?api-version=2023-05-01" \
          --headers "Content-Type=application/json" \
          --body @/tmp/containerapp-updated.json
        
        # Wait for deployment to complete and verify status
        echo "Waiting for container app to be ready..."
        sleep 10
        
        # Get the container app URL
        APP_URL=$(az containerapp show \
          --name $CONTAINER_APP_NAME \
          --resource-group $AZURE_RESOURCE_GROUP \
          --query properties.configuration.ingress.fqdn -o tsv)
        
        echo "Container App URL: https://${APP_URL}"
        echo "Testing health endpoint..."
        
        # Test the health endpoint
        for i in {1..6}; do
          echo "Attempt $i/6..."
          if curl -f -s "https://${APP_URL}/api/health/live" > /dev/null; then
            echo "Health check passed!"
            break
          else
            echo "Health check failed, waiting 10 seconds..."
            sleep 10
          fi
        done 