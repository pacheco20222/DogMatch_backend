name: Deploy Backend to Azure Container Apps

on:
  push:
    branches:
      - main

permissions:
  id-token: write
  contents: read

env:
  AZURE_RESOURCE_GROUP: dogmatch-app
  AZURE_CONTAINERAPPS_ENVIRONMENT: dogmatch-env
  AZURE_CONTAINER_REGISTRY_LOGIN_SERVER: dogmtachcr.azurecr.io
  CONTAINER_APP_NAME: dogmatch-backend

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Login to Azure (OIDC)
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Azure CLI - Log in to ACR
      run: |
        az acr login --name dogmtachcr

    - name: Build Docker image
      run: |
        IMAGE_TAG=${{ env.AZURE_CONTAINER_REGISTRY_LOGIN_SERVER }}/dogmatch-backend:${{ github.sha }}
        echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV
        docker build -t $IMAGE_TAG .

    - name: Push Docker image
      run: |
        docker push $IMAGE_TAG

    - name: Deploy to Azure Container Apps
      run: |
        # First, update the image and basic configuration
        az containerapp update \
          --name $CONTAINER_APP_NAME \
          --resource-group $AZURE_RESOURCE_GROUP \
          --image $IMAGE_TAG \
          --set properties.configuration.ingress.external=true \
          --set properties.configuration.ingress.targetPort=5002 \
          --set properties.configuration.ingress.allowInsecure=true \
          --set properties.configuration.ingress.transport=http \
          --set properties.configuration.ingress.clientCertificateMode=ignore \
          --set properties.template.scale.minReplicas=1 \
          --set properties.template.scale.maxReplicas=1 \
          --set-env-vars \
            FLASK_ENV=production \
            DATABASE_URL=${{ secrets.DATABASE_URL }} \
            REDIS_URL=${{ secrets.REDIS_URL }} \
            SECRET_KEY="${{ secrets.SECRET_KEY }}" \
            JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}" \
            AWS_ACCESS_KEY_ID="${{ secrets.AWS_ACCESS_KEY_ID }}" \
            AWS_SECRET_ACCESS_KEY="${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            AWS_DEFAULT_REGION="${{ secrets.AWS_DEFAULT_REGION }}" \
            S3_BUCKET_NAME="${{ secrets.S3_BUCKET_NAME }}" \
            GEMINI_API_KEY="${{ secrets.GEMINI_API_KEY }}" \
            JWT_ACCESS_TOKEN_EXPIRES="${{ secrets.JWT_ACCESS_TOKEN_EXPIRES }}" \
            JWT_REFRESH_TOKEN_EXPIRES="${{ secrets.JWT_REFRESH_TOKEN_EXPIRES }}"
        
        # Get current container app configuration and update probes using Python
        python3 << EOF
        import json
        import subprocess
        import sys
        import os
        
        container_app_name = os.environ['CONTAINER_APP_NAME']
        resource_group = os.environ['AZURE_RESOURCE_GROUP']
        
        # Get current container app config
        result = subprocess.run(
            ['az', 'containerapp', 'show', 
             '--name', container_app_name,
             '--resource-group', resource_group,
             '--output', 'json'],
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print(f"Error getting container app: {result.stderr}", file=sys.stderr)
            sys.exit(1)
        
        config = json.loads(result.stdout)
        
        # Define probes
        # Startup: Frequent during startup (only runs until success)
        # Liveness: Less frequent - just checks if app is alive
        # Readiness: Moderate frequency - checks if ready for traffic
        probes = [
            {
                "type": "Startup",
                "httpGet": {
                    "path": "/api/health/live",
                    "port": 5002,
                    "scheme": "HTTP"
                },
                "initialDelaySeconds": 10,
                "periodSeconds": 5,
                "timeoutSeconds": 3,
                "failureThreshold": 30,
                "successThreshold": 1
            },
            {
                "type": "Liveness",
                "httpGet": {
                    "path": "/api/health/live",
                    "port": 5002,
                    "scheme": "HTTP"
                },
                "initialDelaySeconds": 30,
                "periodSeconds": 30,
                "timeoutSeconds": 5,
                "failureThreshold": 3,
                "successThreshold": 1
            },
            {
                "type": "Readiness",
                "httpGet": {
                    "path": "/api/health/ready",
                    "port": 5002,
                    "scheme": "HTTP"
                },
                "initialDelaySeconds": 10,
                "periodSeconds": 15,
                "timeoutSeconds": 3,
                "failureThreshold": 3,
                "successThreshold": 1
            }
        ]
        
        # Update probes in the existing container config
        # Get the existing container to preserve all settings
        existing_container = config['properties']['template']['containers'][0].copy()
        existing_container['probes'] = probes
        
        # For PATCH, send the template with updated probes
        # This preserves all other container settings (env vars, resources, etc.)
        update_payload = {
            'properties': {
                'template': {
                    'containers': [existing_container]
                }
            }
        }
        
        # Save update payload as JSON
        with open('/tmp/containerapp-updated.json', 'w') as f:
            json.dump(update_payload, f)
        
        print("Configuration updated successfully")
        EOF
        
        # Apply the updated configuration using az rest (PATCH operation)
        # Get the subscription ID
        SUBSCRIPTION_ID=$(az account show --query id -o tsv)
        
        # Use az rest to update the container app with the PATCH payload
        az rest --method PATCH \
          --uri "https://management.azure.com/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${AZURE_RESOURCE_GROUP}/providers/Microsoft.App/containerApps/${CONTAINER_APP_NAME}?api-version=2023-05-01" \
          --headers "Content-Type=application/json" \
          --body @/tmp/containerapp-updated.json
        
        # Wait for deployment to complete and verify status
        echo "Waiting for container app to be ready..."
        sleep 10
        
        # Get the container app URL
        APP_URL=$(az containerapp show \
          --name $CONTAINER_APP_NAME \
          --resource-group $AZURE_RESOURCE_GROUP \
          --query properties.configuration.ingress.fqdn -o tsv)
        
        echo "Container App URL: https://${APP_URL}"
        echo "Testing health endpoint..."
        
        # Test the health endpoint
        for i in {1..6}; do
          echo "Attempt $i/6..."
          if curl -f -s "https://${APP_URL}/api/health/live" > /dev/null; then
            echo "✅ Health check passed!"
            break
          else
            echo "⏳ Health check failed, waiting 10 seconds..."
            sleep 10
          fi
        done 